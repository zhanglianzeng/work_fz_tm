/*============================================================================
Filename : driven_shield.c
Project : QTouch Modular Library
Purpose : Provides drivenshield support for SAM microcontorllers

This file is part of QTouch Modular Library Release 7.4.1 application.

Important Note: Do not edit this file manually.
                Use QTouch Configurator within Microhchip START to apply any
                modifications to this file.

Usage License: Refer license.h file for license information
Support: Visit http://www.microchip.com/support/hottopics.aspx
               to create MySupport case.

------------------------------------------------------------------------------
Copyright (c) 2020 Microchip. All rights reserved.
------------------------------------------------------------------------------
============================================================================*/

//#include <atmel_start.h>
#include "driven_shield.h"
#include "touch.h"
#include "license.h"
#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>
#include "include/qtm_acq_samc21_0x0020_api.h"
#include "include/qtm_binding_layer_0x0005_api.h"
#include "include/qtm_common_components_api.h"
#include "include/qtm_touch_key_0x0002_api.h"
#include "include/touch_api_ptc.h"

#include "../../../Device/component/tc.h"
#include "../../../Device/component/eic.h"
#include "../../../Device/component/freqm.h"
#include "../../../Device/component/wdt.h"
#include "../../../Device/component/tcc.h"
#include "../../../Device/component/divas.h"
#include "../../../Device/samc21n18a.h"
#include "../../driver/tc.h"
#include "../../driven_dmac.h"

#if (DEF_ENABLE_DRIVEN_SHIELD == 1u)

/* DMA channel used to confiugre filter level */
#define SHIELD_DMA_CHANNEL 0u

qtm_drivenshield_config_t qtm_drivenshield_config;

static const uint8_t offset_vs_prescaler[4] = {4, 3, 3, 4};

/*========================TC for shield======================== */

typedef uint16_t hri_tc_evctrl_reg_t;
typedef uint16_t hri_tccount16_cc_reg_t;
typedef uint16_t hri_tccount16_ccbuf_reg_t;
typedef uint16_t hri_tccount16_count_reg_t;
typedef uint32_t hri_tc_ctrla_reg_t;
typedef uint32_t hri_tc_syncbusy_reg_t;
typedef uint32_t hri_tccount32_cc_reg_t;
typedef uint32_t hri_tccount32_ccbuf_reg_t;
typedef uint32_t hri_tccount32_count_reg_t;
typedef uint8_t hri_tc_ctrlbset_reg_t;
typedef uint8_t hri_tc_dbgctrl_reg_t;
typedef uint8_t hri_tc_drvctrl_reg_t;
typedef uint8_t hri_tc_intenset_reg_t;
typedef uint8_t hri_tc_intflag_reg_t;
typedef uint8_t hri_tc_status_reg_t;
typedef uint8_t hri_tc_wave_reg_t;
typedef uint8_t hri_tccount8_cc_reg_t;
typedef uint8_t hri_tccount8_ccbuf_reg_t;
typedef uint8_t hri_tccount8_count_reg_t;
typedef uint8_t hri_tccount8_per_reg_t;
typedef uint8_t hri_tccount8_perbuf_reg_t;

static inline void hri_tc_wait_for_sync(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	while (((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg)
	{
	};
}

static inline void hri_tc_write_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t data)
{

	((Tc *)hw)->COUNT16.CTRLA.reg = data;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
}

static inline void hri_tc_write_EVCTRL_reg(const void *const hw, hri_tc_evctrl_reg_t data)
{

	((Tc *)hw)->COUNT16.EVCTRL.reg = data;
}

static void hri_tc_write_CTRLA_ENABLE_bit(const void *const hw, bool value)
{
	uint32_t tmp;

	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
	tmp &= ~TC_CTRLA_ENABLE;
	tmp |= value << TC_CTRLA_ENABLE_Pos;
	((Tc *)hw)->COUNT16.CTRLA.reg = tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
}

static inline void hri_tc_write_WAVE_reg(const void *const hw, hri_tc_wave_reg_t data)
{

	((Tc *)hw)->COUNT16.WAVE.reg = data;
}

static inline void hri_tc_write_CTRLB_reg(const void *const hw, hri_tc_ctrlbset_reg_t data)
{
	((Tc *)hw)->COUNT16.CTRLBSET.reg = data;
	((Tc *)hw)->COUNT16.CTRLBCLR.reg = ~data;
}

static inline hri_tc_ctrla_reg_t hri_tc_get_CTRLA_reg(const void *const hw, hri_tc_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
	tmp &= mask;
	return tmp;
}

static inline bool hri_tc_is_syncing(const void *const hw, hri_tc_syncbusy_reg_t reg)
{
	return ((Tc *)hw)->COUNT8.SYNCBUSY.reg & reg;
}

static inline void hri_tccount8_write_PER_PER_bf(const void *const hw, hri_tccount8_per_reg_t data)
{
	uint8_t tmp;
	tmp = ((Tc *)hw)->COUNT8.PER.reg;
	tmp &= ~TC_COUNT8_PER_PER_Msk;
	tmp |= TC_COUNT8_PER_PER(data);
	((Tc *)hw)->COUNT8.PER.reg = tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_PER);
}

static inline void hri_tc_write_CTRLA_PRESCALER_bf(const void *const hw, hri_tc_ctrla_reg_t data)
{
	uint32_t tmp;
	tmp = ((Tc *)hw)->COUNT16.CTRLA.reg;
	tmp &= ~TC_CTRLA_PRESCALER_Msk;
	tmp |= TC_CTRLA_PRESCALER(data);
	((Tc *)hw)->COUNT16.CTRLA.reg = tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_MASK);
}

static inline void hri_tccount8_write_CC_CC_bf(const void *const hw, uint8_t index, hri_tccount8_cc_reg_t data)
{
	uint8_t tmp;
	tmp = ((Tc *)hw)->COUNT8.CC[index].reg;
	tmp &= ~TC_COUNT8_CC_CC_Msk;
	tmp |= TC_COUNT8_CC_CC(data);
	((Tc *)hw)->COUNT8.CC[index].reg = tmp;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_CC0 | TC_SYNCBUSY_CC1);
}

static inline void hri_tccount8_write_COUNT_reg(const void *const hw, hri_tccount8_count_reg_t data)
{
	((Tc *)hw)->COUNT8.COUNT.reg = data;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_COUNT);
}

static inline void hri_tc_set_CTRLA_ENABLE_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.CTRLA.reg |= TC_CTRLA_ENABLE;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
}

static inline void hri_tc_clear_CTRLA_ENABLE_bit(const void *const hw)
{
	((Tc *)hw)->COUNT16.CTRLA.reg &= ~TC_CTRLA_ENABLE;
	hri_tc_wait_for_sync(hw, TC_SYNCBUSY_SWRST | TC_SYNCBUSY_ENABLE);
}

void SHIELD_TC_PWM_init(void)
{

	if (!hri_tc_is_syncing(TC3, TC_SYNCBUSY_SWRST))
	{
		if (hri_tc_get_CTRLA_reg(TC3, TC_CTRLA_ENABLE))
		{
			hri_tc_clear_CTRLA_ENABLE_bit(TC3);
			hri_tc_wait_for_sync(TC3, TC_SYNCBUSY_ENABLE);
		}
		hri_tc_write_CTRLA_reg(TC3, TC_CTRLA_SWRST);
	}
	hri_tc_wait_for_sync(TC3, TC_SYNCBUSY_SWRST);

	hri_tc_write_CTRLA_reg(TC3,
						   0 << TC_CTRLA_COPEN0_Pos			 /* Capture Pin 0 Enable: disabled */
							   | 0 << TC_CTRLA_COPEN1_Pos	 /* Capture Pin 1 Enable: disabled */
							   | 0 << TC_CTRLA_CAPTEN0_Pos	 /* Capture Channel 0 Enable: disabled */
							   | 0 << TC_CTRLA_CAPTEN1_Pos	 /* Capture Channel 1 Enable: disabled */
							   | 0 << TC_CTRLA_ALOCK_Pos	 /* Auto Lock: disabled */
							   | 0 << TC_CTRLA_PRESCSYNC_Pos /* Prescaler and Counter Synchronization: 0 */
							   | 0 << TC_CTRLA_ONDEMAND_Pos	 /* Clock On Demand: disabled */
							   | 1 << TC_CTRLA_RUNSTDBY_Pos	 /* Run in Standby: enabled */
							   | 0 << TC_CTRLA_PRESCALER_Pos /* Setting: 0 */
							   | 0x1 << TC_CTRLA_MODE_Pos);	 /* Operating Mode: 0x1 */

	hri_tc_write_CTRLB_reg(TC3,
						   0 << TC_CTRLBSET_CMD_Pos			  /* Command: 0 */
							   | 0 << TC_CTRLBSET_ONESHOT_Pos /* One-Shot: disabled */
							   | 0 << TC_CTRLBCLR_LUPD_Pos	  /* Setting: disabled */
							   | 0 << TC_CTRLBSET_DIR_Pos);	  /* Counter Direction: disabled */

	hri_tc_write_WAVE_reg(TC3, 2); /* Waveform Generation Mode: 2 */

	// hri_tc_write_DRVCTRL_reg(TC3,0 << TC_DRVCTRL_INVEN1_Pos /* Output Waveform 1 Invert Enable: disabled */
	//		 | 0 << TC_DRVCTRL_INVEN0_Pos); /* Output Waveform 0 Invert Enable: disabled */

	// hri_tc_write_DBGCTRL_reg(TC3,0); /* Run in debug: 0 */

	// hri_tccount8_write_CC_reg(TC3, 0 ,0x0); /* Compare/Capture Value: 0x0 */

	// hri_tccount8_write_CC_reg(TC3, 1 ,0x0); /* Compare/Capture Value: 0x0 */

	// hri_tccount8_write_COUNT_reg(TC3,0x0); /* Counter Value: 0x0 */

	// hri_tc_write_PER_reg(TC3,0x0); /*  Period Value: 0x0 */

	hri_tc_write_EVCTRL_reg(
		TC3,
		0 << TC_EVCTRL_MCEO0_Pos	   /* Match or Capture Channel 0 Event Output Enable: disabled */
			| 0 << TC_EVCTRL_MCEO1_Pos /* Match or Capture Channel 1 Event Output Enable: disabled */
			| 0 << TC_EVCTRL_OVFEO_Pos /* Overflow/Underflow Event Output Enable: disabled */
			| 1 << TC_EVCTRL_TCEI_Pos  /* TC Event Input: enabled */
			| 0 << TC_EVCTRL_TCINV_Pos /* TC Inverted Event Input: disabled */
			| 3);					   /* Event Action: 3 */

	// hri_tc_write_INTEN_reg(TC3,0 << TC_INTENSET_MC0_Pos /* Match or Capture Channel 0 Interrupt Enable: disabled */
	//		 | 0 << TC_INTENSET_MC1_Pos /* Match or Capture Channel 1 Interrupt Enable: disabled */
	//		 | 0 << TC_INTENSET_ERR_Pos /* Error Interrupt Enable: disabled */
	//		 | 0 << TC_INTENSET_OVF_Pos); /* Overflow Interrupt enable: disabled */

	hri_tc_write_CTRLA_ENABLE_bit(TC3, 1 << TC_CTRLA_ENABLE_Pos); /* Enable: enabled */
}

/*============================================================================
void drivenshield_configure()
------------------------------------------------------------------------------
Purpose: Sets up the qtm_drivenshield_config_t qtm_drivenshield_config object
Input  : Users application / configuration parameters
Output : None
Notes  : This setup is very product dependent,
         users can setup the delays between the SW_Trigger event and
         PWM2 and PTC start, Select Two or Three level Shield mode
         Users also use this function to configure GPIO pins and Enable
         GCLKs and APBClocks for the peripherals associated with the shield
============================================================================*/
void drivenshield_configure()
{
	touch_ret_t touch_ret = TOUCH_SUCCESS;
	/* Shield configuration */
	touch_ret = qtm_drivenshield_setup(&qtm_drivenshield_config);
	if (touch_ret != TOUCH_SUCCESS)
	{
		while (1)
			;
	}
	touch_ret = qtm_drivenshield_register_start_callback(&drivenshield_start);
	if (touch_ret != TOUCH_SUCCESS)
	{
		while (1)
			;
	}
}

/*============================================================================
void drivenshield_start(uint8_t csd, uint8_t sds, uint8_t prescaler, uint32_t volatile *dst_addr, uint32_t value)
------------------------------------------------------------------------------
Purpose: user call back from the SAMD21 Acquisition engine
Input  : Charge Share Delay (CSD) setting from PTC Acq. engine, (Set to 0 in SAMD21)
         Sample Delay Selection (SDS) setting from PTC Acq. engine this is the Frequency Hop Value for this cycle
         Prescaler setting from the PTC Acq. Engine
Output : None
Notes  : This function uses the EVSYS to start the PTC to acquire touch
============================================================================*/
void drivenshield_start(uint8_t csd, uint8_t sds, uint8_t prescaler, uint32_t volatile *dst_addr, uint32_t value)
{
	static uint32_t filter_level = 0;
	static uint32_t *addr;
	uint16_t period = 0, count = 0, cc = 0;

	addr = (uint32_t *)dst_addr;
	filter_level = value;

	/* Configure DMA to transfer data at PTC EOC */
	DMAC_Set_Source_Address(SHIELD_DMA_CHANNEL, (uint32_t *)&filter_level);
	DMAC_Set_Destination_Address(SHIELD_DMA_CHANNEL, (uint32_t *)addr);
	DMAC_Set_Data_Amount(SHIELD_DMA_CHANNEL, (uint32_t)3);
	DMAC_Enable_Transaction(SHIELD_DMA_CHANNEL, false);

	/* TC/TCC period value */
	period = csd + 1;
	period = period * 6;
	period = period + sds + 1;
	period = period << 2;
	period = period - 1;

	/* TC/TCC compare value */
	cc = csd + 1;
	cc = cc * 3;
	cc = cc << 2;
	cc = cc + (sds << 2);

	/* TC/TCC count value - initial offset */
	count = csd + 1;
	count = count * 2;
	count = count << 2;
	period = period - 4;
	cc = cc - 2;

	while (period > 255)
	{
		prescaler = prescaler + 1;
		period = period >> 1;
		cc = cc >> 1;
		count = count >> 1;
	}

	/* Shield configuration */
	hri_tc_clear_CTRLA_ENABLE_bit(TC3);
	hri_tccount8_write_PER_PER_bf(TC3, (uint8_t)period);
	hri_tc_write_CTRLA_PRESCALER_bf(TC3, prescaler);
	hri_tccount8_write_CC_CC_bf(TC3, 1, (uint8_t)cc);
	hri_tccount8_write_COUNT_reg(TC3, (uint8_t)count);
	hri_tc_set_CTRLA_ENABLE_bit(TC3);

}

/*============================================================================
void drivenshield_stop(void)
------------------------------------------------------------------------------
Purpose: Stops the softshield timers
Input  : none
Output : none
Notes  : This function is called from the PTC EOC handler in the users application in touch.c
============================================================================*/
void drivenshield_stop(void)
{
	/* Stop shield event if thats an option. could set that the PTC Handler in touch.c  */

	hri_tc_clear_CTRLA_ENABLE_bit(TC3);
}

/*============================================================================
void drivenshield_disable_eoc_event(void);
------------------------------------------------------------------------------
Purpose: Disconnects the EOC as an event generator
Input  : All parameters are set to 0,
Output : none
Notes  : This function is called from the PTC EOC handler in the users application in touch.c
============================================================================*/
void drivenshield_disable_eoc_event()
{
	/* nothing to be done for SAMC Devices */
}

#endif
